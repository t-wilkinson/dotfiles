# Preserve tmux sessions
if [[ $DISPLAY ]]; then
    # if not running interactively: don't do anything.
  [[ $- != *i* ]] && return

  if [[ -z "$TMUX" ]]; then
    detached="$( tmux ls 2> /dev/null | grep -vm1 attached | cut -d: -f1 )"
    attached="$(tmux ls 2> /dev/null |  cut -d: -f1)"

    if [[ "$attached" = "Main" ]]; then
      tmuxp load work
    elif [[ "$detached" = "Main" ]]; then
      tmux attach-session -t "$detached"
    else
      tmuxp load main
      # tmux new-session -s "Main" -n "main"
    fi
  fi
else
    # Bash is better for tty
    /usr/bin/env bash
    return
fi

# Prompt
# [[ $IN_NIX_SHELL ]] || neofetch
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
    source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
if [[ -f ~/.p10k.zsh ]]; then
    source ~/.p10k.zsh
fi

fpath=(~/.stripe $fpath)
autoload -Uz compinit && compinit -i

# To customize prompt, run `p10k configure` or edit ~/dev/dotfiles/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

autoload -Uz promptinit
promptinit
source /usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme
# prompt powerlevel10k

# Change cursor with support for inside/outside tmux
if [[ ! $TERM = "eterm-color" ]]; then
    bindkey -v
    function _set_cursor() {
        if [[ $TMUX = '' ]]; then
          echo -ne $1
        else
          echo -ne "\ePtmux;\e\e$1\e\\"
        fi
    }
    function _set_block_cursor() { _set_cursor '\e[2 q' }
    function _set_beam_cursor() { _set_cursor '\e[6 q' }
    function zle-keymap-select {
      if [[ ${KEYMAP} == vicmd ]] || [[ $1 = 'block' ]]; then
          _set_block_cursor
      else
          _set_beam_cursor
      fi
    }
    zle -N zle-keymap-select
    # ensure beam cursor when starting new terminal
    precmd_functions+=(_set_beam_cursor)
    # ensure insert mode and beam cursor when exiting vim
    zle-line-init() { zle -K viins; _set_beam_cursor }
    # 10ms for key sequences
    KEYTIMEOUT=1
fi

# FZF
# generate path
_fzf_compgen_path() {
  fd --hidden --follow --exclude ".git" . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
  fd --type d --hidden --follow --exclude ".git" . "$1"
}

# search on lines of every file in current directory
# return files which match the searched line
fzf-lines() {
    # get every line in directory '$1'
    # regex=${1:-"."} # default to all files
    # paths=${${@:2}:-"."} # default to current directory
    # lines=$(fd "$regex" $paths -t f -x cat {} | fzf +m)
    lines=$(fd $@ -t f -x cat {} | fzf +m)
    # get all lines that match users selection
    rg -s -F -l "$lines" | fzf -1
}

# 'fzf' on all lines in all files found with 'fd'
# populate 'vim' quickfix with results
fzf-vim() {
    # lines=$(fd $@ -t f -x cat {} | fzf -m)
    quickfix=$(rg --vimgrep -F -f <(fd $@ -t f -x cat {} | fzf -m)) # generate quickfix for vim
    # quit if no results
    [[ -z $quickfix ]] && return
    vim -q <(echo -n $quickfix) # open vim, populating quickfix
}

# fzf cd
fzf-cd() {
    cd $(fd -t d . ${1:-.} | fzf)
}

# fzf cd to file dir
fzf-cf() {
    files=$(fd -t f | fzf)
    if [[ -n $files ]]; then
        cd $(dirname $files)
    fi
}

fzf-prj() {
    cd $(prj fzf)
}

# ls on cd
function cd {
    builtin cd "$@" && ls -aF
}

pkgs() {
    case $1 in
        size)
            if [[ -z $2 ]]; then
                LC_ALL=C pacman -Qi | awk '/^Name/{name=$3} /^Installed Size/{ print $4$5, "\t", name}' | sort -h
            else
                pkg=$2
                pacman -Qlq $pkg | grep -v '/$' | xargs -r du -h | sort -h
            fi
            ;;

        install)
            pkglist=$2
            if [[ -f /home/trey/dev/t-wilkinson/scripts/pkglist.txt ]]; then
                pkglist=/home/trey/dev/t-wilkinson/scripts/pkglist.txt
            fi

            pacman -S --needed $(comm -12 <(pacman -Slq | sort) <(sort $pkglist))
            ;;

        *)
            echo "No matching command"
            ;;
    esac
}

# re-run command on file change
forever() {
    $@
    while inotifywait -r -e modify .; do
        clear
        $@ # run function
    done
}

# ssh... with tmux
ssh-tmux() {
    ssh -t $@ -- /bin/sh -c 'tmux has-session && exec tmux attach || exec tmux'
}
compdef '_dispatch ssh ssh'

# print nth line of stdin
n() {
    head -$1 | tail -1
}

# steal children, murder parent
steal() {
    setopt -s dotglob
    mv "$1"/* "${2:-.}"/
    rm -r "$1"
}

# swap two files/folders
swap() {
    tmp=$(mktemp)
    mv $1 $tmp
    mv $2 $1
    mv $tmp $2
}

line-count() {
    # fd -E build $@ | xargs -I% wc -l % | awk '{ sum += $1}; END { print sum}'
    # exts=()
    # exclude=()

    # while [[ $# > 0 ]]; do
    #     case $1 in
    #         -e)
    #             for e in $(echo $2 | tr ',' ' '); do
    #                 exts+=('-e')
    #                 exts+=($e)
    #             done
    #             shift
    #             ;;
    #         -E)
    #             for e in $(echo $2 | tr ',' '\n'); do
    #                 exclude+=("-E" $e)
    #             done
    #             shift
    #             ;;
    #         *) ;;
    #     esac
    #     shift
    # done

    # echo ${exts[@]}
    # IFS=" "
    # for v in "${exts[@]}"; do
    #     echo $v
    # done
    # for v in ${exclude[@]}; do
    #     echo $v
    # done

    fd -t f -E build $@ | tr '\n' '\0' | wc -l --files0-from=- | sort -n
}

# simple unification of command help
help() {
    cmd="$1"
    args="${@:2}"
    eval "$cmd" help "$args" 2>/dev/null || eval "$cmd" --help "$args" 2>/dev/null || eval "$cmd" -h "$args" 2>/dev/null
}

docker_run_status() {
    user=$(pass ls github.credentials.t-wilkinson | sed 's/\(username\|password\)=//' | head -c -1 | tr '\n' ':')
    # user=$(pass ls github.credentials.t-wilkinson | tr '=' ' ' | awk '{ print $2 }' | head -c -1 | tr '\n' ':')
    curl -s -X GET \
        -u "$user" \
        https://api.github.com/repos/t-wilkinson/infinite-closet/commits/dev/check-runs | python -c '
import json
import sys
for run in json.load(sys.stdin)["check_runs"]:
    # print(json.dumps(run, indent=4, sort_keys=True))
    print(run["completed_at"], run["status"], run["conclusion"])
'
}

# make any necessary directories before creating file
touchd () {
    mkdir -p $(dirname $1)
    touch $(basename $1)
}

# for copying bash commands from instructions ($ echo 'hello world')
$ () { eval "$@" }

compdef _ssh ssh-tmux

# bindkey [-l]  <- to view binded keys and their respective commands
bindkey "^Y" list-expand  # for completion

# PYENV
eval "$(pyenv virtualenv-init -)"
# command pyenv rehash 2>/dev/null
# pyenv() {
#   local command
#   command="${1:-}"
#   if [ "$#" -gt 0 ]; then
#     shift
#   fi
#
#   case "$command" in
#   activate|deactivate|rehash|shell)
#     eval "$(pyenv "sh-$command" "$@")"
#     ;;
#   *)
#     command pyenv "$command" "$@"
#     ;;
#   esac
# }

# NVM
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
source /usr/share/nvm/init-nvm.sh
